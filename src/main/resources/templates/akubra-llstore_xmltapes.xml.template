<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
     http://www.springframework.org/schema/util  http://www.springframework.org/schema/util/spring-util-3.0.xsd">

    <!--Standard-->
    <bean name="org.fcrepo.server.storage.lowlevel.ILowlevelStorage"
          class="org.fcrepo.server.storage.lowlevel.akubra.AkubraLowlevelStorageModule">
        <constructor-arg index="0">
            <map/>
        </constructor-arg>
        <constructor-arg index="1" ref="org.fcrepo.server.Server"/>
        <constructor-arg index="2" type="java.lang.String"
                         value="org.fcrepo.server.storage.lowlevel.ILowlevelStorage"/>
        <property name="impl"
                  ref="org.fcrepo.server.storage.lowlevel.akubra.AkubraLowlevelStorage"/>
    </bean>

    <bean name="org.fcrepo.server.storage.lowlevel.akubra.AkubraLowlevelStorage"
          class="org.fcrepo.server.storage.lowlevel.akubra.AkubraLowlevelStorage"
            >
        <constructor-arg ref="tapeObjectStore">
            <description>The store of serialized Fedora objects</description>
            <!--Here we reference our tape system-->
        </constructor-arg>
        <constructor-arg ref="tapeDatastreamStore">
            <description>The store of datastream content</description>
            </constructor-arg>
        <constructor-arg value="false"><!--This is set to false, as we do not ever delete stuff-->
            <description>if true, replaceObject calls will be done in a way
                that
                ensures the old content is not deleted until the new content is safely
                written. If the objectStore already does this, this should be
                given as
                false
            </description>
        </constructor-arg>
        <constructor-arg value="false">
            <description>save as above, but for datastreamStore</description>
        </constructor-arg>
    </bean>

    <!--This is the tape store Akubra Implementation-->
    <bean name="tapeObjectStore"
          class="dk.statsbiblioteket.metadatarepository.xmltapes.akubra.XmlTapesBlobStore"
            >
        <constructor-arg value="urn:example.org:tapeObjectStore"/>
        <!--This parameter is the name of the storage. -->
        <property name="archive" ref="cacheTapeObjectStore"/>
        <!--And this is the reference to the actual implementation-->
    </bean>

    <!--This is the tape store Akubra Implementation-->
    <bean name="tapeDatastreamStore"
          class="dk.statsbiblioteket.metadatarepository.xmltapes.akubra.XmlTapesBlobStore"
            >
        <constructor-arg value="urn:example.org:tapeDatastreamStore"/>
        <!--This parameter is the name of the storage. -->
        <property name="archive" ref="cacheTapeDatastreamStore"/>
        <!--And this is the reference to the actual implementation-->

    </bean>


    <!--The cache tape object store holds the objects while it is being written and until the taper is ready
    to tape the object-->
    <bean name="cacheTapeObjectStore"
          class="dk.statsbiblioteket.metadatarepository.xmltapes.cache.CacheForDeferringTaper"
            >
        <!--Where to store files until the taper is ready to tape them-->
        <constructor-arg value="$DATA_DIR$/cacheObjectStore" index="0"/>
        <!--Where to store files while they are still being written-->
        <constructor-arg value="$DATA_DIR$/cacheTempObjectStore" index="1"/>
        <!--The two adresses above must be on the same file system as we rely on atomic moves-->

        <!--The delegate for read operations-->
        <property name="delegate" ref="tapingTapeObjectStore"/>

    </bean>

    <!--The cache tape datastreams store holds the datastreams while it is being written and until the taper is ready
    to tape the datastream-->
    <bean name="cacheTapeDatastreamStore"
          class="dk.statsbiblioteket.metadatarepository.xmltapes.cache.CacheForDeferringTaper"
            >
        <!--Where to store files until the taper is ready to tape them-->
        <constructor-arg value="$DATA_DIR$/cacheDatastreamStore" index="0"/>
        <!--Where to store files while they are still being written-->
        <constructor-arg value="$DATA_DIR$/cacheTempDatastreamStore" index="1"/>
        <!--The two adresses above must be on the same file system as we rely on atomic moves-->

        <!--The delegate for read operations-->
        <property name="delegate" ref="tapingTapeDatastreamStore"/>

    </bean>



    <bean name="tapingTapeObjectStore"
          class="dk.statsbiblioteket.metadatarepository.xmltapes.taper.DeferringTaper"
          init-method="init"
            >
         <!--Where to store files until the taper is ready to tape them-->
        <constructor-arg value="$DATA_DIR$/tapingObjectStore" index="0"/>

        <!--The allowed age of an file before it is taped, in ms-->
        <property name="tapeDelay" value="600000"/>
        <!--The delay between invocations of the taper-->
        <property name="delay" value="30000"/>

         <property name="delegate" ref="tarTapeObjectStore"/>

        <!--The cache, to get the objects ready for writing-->
        <property name="parent" ref="cacheTapeObjectStore"/>
     </bean>

    <bean name="tapingTapeDatastreamStore"
          class="dk.statsbiblioteket.metadatarepository.xmltapes.taper.DeferringTaper"
          init-method="init"
            >
         <!--Where to store files until the taper is ready to tape them-->
        <constructor-arg value="$DATA_DIR$/tapingDatastreamStore" index="0"/>

        <!--The allowed age of an file before it is taped, in ms-->
        <property name="tapeDelay" value="600000"/>
        <!--The delay between invocations of the taper-->
        <property name="delay" value="30000"/>

         <property name="delegate" ref="tarTapeDatastreamStore"/>

        <!--The cache, to get the objects ready for writing-->
        <property name="parent" ref="cacheTapeDatastreamStore"/>
     </bean>




    <!--The guts of the tape system-->
    <bean name="tarTapeObjectStore"
          class="dk.statsbiblioteket.metadatarepository.xmltapes.tarfiles.TapeArchiveImpl"
          init-method="init"
            >
        <!--Change the init-method to init, if you do not want to rebuild the redis index on server startup -->


        <!--This constructor argument specifies the tape store location. -->
        <constructor-arg value="file://$DATA_DIR$/objectStore" type="java.net.URI"/>
        <!--This specifies the maximum length a tape can be before a new tape is started-->
        <constructor-arg value="10485760" type="long"/>
        <!--10 MB-->
        <!--This is the reference to the index-->
        <property name="index" ref="redisObjectsIndex"/>
        <!--Remove broken records from the newest tape when initialising-->
        <property name="fixErrors" value="false"/>
        <!--Reindex all the tape files when initialising-->
        <property name="rebuild" value="true"/>

        <!--Extension of the tape files-->
        <constructor-arg value=".tar"/>

        <!--prefix for the tape files-->
        <constructor-arg value="tape"/>

        <!--prefix for the temp tape files-->
        <constructor-arg value="tempTape"/>
    </bean>


    <!--The guts of the tape system-->
    <bean name="tarTapeDatastreamStore"
          class="dk.statsbiblioteket.metadatarepository.xmltapes.tarfiles.TapeArchiveImpl"
          init-method="init"
            >
        <!--Change the init-method to init, if you do not want to rebuild the redis index on server startup -->


        <!--This constructor argument specifies the tape store location. -->
        <constructor-arg value="file://$DATA_DIR$/datastreamStore" type="java.net.URI"/>
        <!--This specifies the maximum length a tape can be before a new tape is started-->
        <constructor-arg value="10485760" type="long"/>
        <!--10 MB-->
        <!--This is the reference to the index-->
        <property name="index" ref="redisDatastreamIndex"/>
        <!--Remove broken records from the newest tape when initialising-->
        <property name="fixErrors" value="false"/>
        <!--Reindex all the tape files when initialising-->
        <property name="rebuild" value="true"/>

        <!--Extension of the tape files-->
        <constructor-arg value=".tar"/>

        <!--prefix for the tape files-->
        <constructor-arg value="tape"/>

        <!--prefix for the temp tape files-->
        <constructor-arg value="tempTape"/>
    </bean>


    <!--This is our objects Redis index-->
    <bean name="redisObjectsIndex" class="dk.statsbiblioteket.metadatarepository.xmltapes.redis.RedisIndex"
            >
        <constructor-arg type="redis.clients.jedis.JedisPoolConfig" ref="jedisPoolConfig"/>

        <!--The redis server-->
        <constructor-arg value="$REDIS_HOST$" />
        <!--The port it is running on-->
        <constructor-arg value="$REDIS_PORT$"/>
        <!--The database name. Redis databases are always identified by integers-->
        <constructor-arg value="0"/><!--Database name-->
    </bean>

    <!--This is our datastream Redis index-->
    <bean name="redisDatastreamIndex" class="dk.statsbiblioteket.metadatarepository.xmltapes.redis.RedisIndex"
            >
        <constructor-arg type="redis.clients.jedis.JedisPoolConfig" ref="jedisPoolConfig"/>

        <!--The redis server-->
        <constructor-arg value="$REDIS_HOST$" />
        <!--The port it is running on-->
        <constructor-arg value="$REDIS_PORT$"/>
        <!--The database name. Redis databases are always identified by integers-->
        <constructor-arg value="1"/><!--Database name-->
    </bean>



    <!--Standard storage for managed datastreams. We do not use managed datastreams-->
    <bean name="datastreamStore" class="org.akubraproject.map.IdMappingBlobStore"
            >
        <constructor-arg value="urn:fedora:datastreamStore"/>
        <constructor-arg>
            <ref bean="fsDatastreamStore"/>
        </constructor-arg>
        <constructor-arg>
            <ref bean="fsDatastreamStoreMapper"/>
        </constructor-arg>
    </bean>

    <!--Standard storage for managed datastreams. We do not use managed datastreams-->
    <bean name="fsDatastreamStore" class="org.akubraproject.fs.FSBlobStore"
            >
        <constructor-arg value="urn:example.org:fsDatastreamStore"/>
        <constructor-arg value="$DATA_DIR$/datastreamStore"/>

    </bean>


    <bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">
        <!-- Action to take when trying to acquire a connection and all connections are taken -->
        <property name="whenExhaustedAction">
            <!-- Fail-fast behaviour, we don't like to keep the kids waiting -->
            <util:constant static-field="org.apache.commons.pool.impl.GenericObjectPool.WHEN_EXHAUSTED_BLOCK"/>
        </property>
        <!-- Maximum active connections to Redis instance -->
        <property name="maxActive" value="10"/>
        <!-- Number of connections to Redis that just sit there and do nothing -->
        <property name="maxIdle" value="5"/>
        <!-- Minimum number of idle connections to Redis - these can be seen as always open and ready to serve -->
        <property name="minIdle" value="1"/>
        <!-- Tests whether connection is dead when connection retrieval method is called -->
        <property name="testOnBorrow" value="true"/>
        <!-- Tests whether connection is dead when returning a connection to the pool -->
        <property name="testOnReturn" value="true"/>
        <!-- Tests whether connections are dead during idle periods -->
        <property name="testWhileIdle" value="true"/>
        <!-- Maximum number of connections to test in each idle check -->
        <property name="numTestsPerEvictionRun" value="10"/>
        <!-- Idle connection checking period -->
        <property name="timeBetweenEvictionRunsMillis" value="60000"/>
        <!-- Maximum time, in milliseconds, to wait for a resource when exausted action is set to WHEN_EXAUSTED_BLOCK -->
        <property name="maxWait" value="30000"/>
    </bean>


    <!--Standard storage for managed datastreams. We do not use managed datastreams-->
    <bean name="fsDatastreamStoreMapper"
          class="org.fcrepo.server.storage.lowlevel.akubra.HashPathIdMapper"
            >
        <constructor-arg value="##"/>
    </bean>


    <bean name="fedoraStorageHintProvider"
          class="org.fcrepo.server.storage.NullStorageHintsProvider"
            >
    </bean>

</beans>

